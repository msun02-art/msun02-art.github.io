<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Planet with Upload</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }

    /* 顶部按钮样式 */
    #topbar {
      position: absolute;
      top: 15px;
      right: 20px;
      background: #333;          /* 深色背景 */
      color: #c2a679;            /* 米色文字 */
      padding: 10px 20px;
      border-radius: 25px;       /* 圆角矩形 */
      font-family: sans-serif;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      transition: all 0.3s ease;
      z-index: 10;
    }
    #topbar:hover {
      background: #555;          /* hover 时更亮 */
      transform: scale(1.05);    /* 轻微放大 */
    }

    #fileInput {
      display: none;
    }
  </style>
</head>
<body>
  <div id="topbar">Design your own AI</div>
  <input type="file" id="fileInput" accept="image/*">

  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    // 场景、相机、渲染器
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.01, 1000);
    camera.position.z = 6;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0xfff5cc); // 背景浅黄色
    document.body.appendChild(renderer.domElement);

    // 星球
    const textureLoader = new THREE.TextureLoader();
    const bumpTexture = textureLoader.load("https://threejs.org/examples/textures/water/Water_1_M_Normal.jpg");
    const sphereGeometry = new THREE.SphereGeometry(2, 128, 128);
    const sphereMaterial = new THREE.MeshPhongMaterial({
      color: 0xA8CF5B,
      bumpMap: bumpTexture,
      bumpScale: 0.2,
      shininess: 10
    });
    const planet = new THREE.Mesh(sphereGeometry, sphereMaterial);
    scene.add(planet);

    // 灯光
    scene.add(new THREE.AmbientLight(0xcccccc, 0.4));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    // OrbitControls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enablePan = false;
    controls.minDistance = 0.5;
    controls.maxDistance = 10;

    // 保留两张默认照片
    function addPhotoSprite(url, theta, phi, link) {
      const texture = new THREE.TextureLoader().load(url);
      const material = new THREE.SpriteMaterial({ map: texture });
      const sprite = new THREE.Sprite(material);

      const R = 2.3;
      sprite.position.set(
        R * Math.sin(theta) * Math.cos(phi),
        R * Math.cos(theta),
        R * Math.sin(theta) * Math.sin(phi)
      );
      sprite.scale.set(1.5, 1.5, 1);
      sprite.userData.link = link;
      scene.add(sprite);
      return sprite;
    }

    const flowerSprite = addPhotoSprite("flower.png", Math.PI/4, Math.PI/3, "flower.html");
    const fishSprite   = addPhotoSprite("fish.png", Math.PI/2.5, Math.PI/1.5, "fish.html");

    // 上传逻辑
    let uploadMode = false;
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    document.getElementById("topbar").addEventListener("click", () => {
      uploadMode = true;
      document.body.style.cursor = "crosshair"; // 鼠标变成锚点
    });

    window.addEventListener("click", (event) => {
      if (!uploadMode) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      const intersects = raycaster.intersectObject(planet);
      if (intersects.length > 0) {
        const point = intersects[0].point; // 点击的球体表面坐标
        const fileInput = document.getElementById("fileInput");
        fileInput.click();

        fileInput.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const url = URL.createObjectURL(file);
          const tex = new THREE.TextureLoader().load(url);
          const mat = new THREE.SpriteMaterial({ map: tex });
          const sprite = new THREE.Sprite(mat);

          // 修复：直接用点击点坐标，并稍微推离表面
          sprite.position.copy(point.multiplyScalar(1.05));
          sprite.scale.set(1.5, 1.5, 1);
          scene.add(sprite);

          uploadMode = false;
          document.body.style.cursor = "default";
        };
      }
    });

    // 背景颗粒感
    const particlesGeometry = new THREE.BufferGeometry();
    const particlesCount = 2000;
    const positions = new Float32Array(particlesCount * 3);
    for (let i = 0; i < particlesCount * 3; i++) {
      positions[i] = (Math.random() - 0.5) * 50;
    }
    particlesGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    const particlesMaterial = new THREE.PointsMaterial({ color: 0x999966, size: 0.05, opacity: 0.6, transparent: true });
    scene.add(new THREE.Points(particlesGeometry, particlesMaterial));

    // 动画循环
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>